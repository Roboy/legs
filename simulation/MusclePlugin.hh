#ifndef _GAZEBO_MUSCLE_HH_
#define _GAZEBO_MUSCLE_HH_

#include "gazebo/common/Plugin.hh"
#include "gazebo/util/system.hh"
#include <sstream>
#include <gazebo/gazebo.hh>
#include <gazebo/physics/physics.hh>
#include <ignition/math/Vector3.hh>
#include <gazebo/common/common.hh>
#include <boost/bind.hpp>
#include <math.h>
#include <map>
#include <stdio.h>
#include <algorithm> 
#include <boost/numeric/odeint.hpp>


#include "Helpers.hh"


namespace gazebo
{
  
	using namespace std;
	using namespace boost::numeric::odeint; 
	
	Motor _motor;
    Gear _gear;
    Spindle _spindle;
    SEE _see;

    float elasticForce;
   	float actuatorForce;
   			
    // const int linkNumber = 3; //later read this number from some table or .txt files
    

	class MusclePlugin : public ModelPlugin
	{
  
	    public: 
	    	MusclePlugin();

	   		void Load(physics::ModelPtr _parent, sdf::ElementPtr _sdf);
	    	void Init();

	   	    // state vector for differential model
			typedef std::vector< double > state_type;

	    private: 
	    	void OnUpdate();

	    	boost::numeric::odeint::runge_kutta4< state_type > stepper;
	    	event::ConnectionPtr connection;
	   		common::Time prevUpdateTime;
	    	
	    	physics::ModelPtr model;
	    	std::vector<physics::LinkPtr> links;
			transport::NodePtr node;
		    transport::PublisherPtr visPub;

		    vector<vector<msgs::Visual>> visualMsg; // visual message visualizing all tendons
		    vector<vector<math::Vector3>> linkRelVec; // save all reletive coordinates of viapoints to each link (body part)

			
		    

		    ////////////////////////////////////////
		    /// \brief Approximates gear's velocity
		    /// according to the direction of the rotation of the gear, i.e. 
		    /// eta or 1/eta
		    /// \return Approximated value for gear efficiency
		    static float EfficiencyApproximation();
		    

		    ////////////////////////////////////////
		    /// \brief Describes the differential model 
		    /// for the simulations of dynamics 
		    /// of a DC motor, a spindle, and a gear box
		    static void DiffModel( const state_type &x , state_type &dxdt , const double /* t */ );
	  
	  		////////////////////////////////////////
		    /// \brief Calculate torque for an electric motor model.
		    /// \param[in] _current Input electric current
		    /// \param[in] _torqueConstant Motor's torque constant
		    /// \param[in] _spindleRadius Radius of the spindle that coils up the tendon
		    /// \return Calculated force according to the model
		    float ElectricMotorModel(const float _current,  const float _torqueConstant, 
		                                const float _spindleRadius);

		    ////////////////////////////////////////
		    /// \brief Calculate elastic force of the series elastic element
		    /// \param[in] _length0 Resting length of the SEE
		    /// \param[in] _length Current length of the SEE 
		    /// \param[in] _stiffness Deafault values for stiffness of the SEE
		    /// \return Elastic force in N
		    float ElasticElementModel(const float _length0, const float _length, 
		                                float _stiffness,  const float _speed, 
		                                const float _spindleRadius, const double _time);

		    ////////////////////////////////////////
		    /// \brief Calculate forces generated by the motor and SEE
		    /// \param[in] _elasticForce
		    /// \param[in] _motorForce  
		    /// \param[in] position and orientation of the tendon
		    /// \return Motor force in N
		    math::Vector3 CalculateForce(float _elasticForce, float _motorForce, 
	                              const math::Vector3 &_tendonOrien);



	    	static void GetTendonInfo(vector<vector<math::Vector3>> _viaPointPose, vector<tendonType> *tendon_p);

  };

}

#endif